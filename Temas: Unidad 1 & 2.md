---
layout: post
title: Proyecto Introduccion Ingenieria en Software.
---

## Introduccion Ingenieria en Software 

![_config.yml]({{ site.baseurl }}/images/12.png)

### Temas Impartidos en horario de clase: 

### Ingenieria en Software:

Definiciones de Ingeniería de Software

#### Definición 1: 

Ingeniería de Software es el estudio de los principios y metodologías para desarrollo y mantenimiento de sistemas de software.

#### Definición 2: 

Ingeniería de Software es la aplicación práctica del conocimiento científico en el diseño y construcción de programas de computadora y la documentación asociada requerida para desarrollar, operar (funcionar) y mantenerlos. Se conoce también como desarrollo de software o producción de software.

#### Definición 3: 

Ingeniería de Software trata del establecimiento de los principios y métodos de la Ingeniería a fin de obtener software de modo rentable que sea fiable y trabaje en máquinas reales.

#### Definición 4: 

La aplicación de un enfoque sistemático, disciplinado y cuantificable al desarrollo, operación (funcionamiento) y mantenimiento del software; es decir, la aplicación de ingeniería al software.

La ingeniería de software es una especialidad que consiste en sistemas, instrumentos y técnicas que se emplean en el desarrollo de los programas informáticos. Es la rama de la ingeniería que estudia todo lo relacionado con la informática o sistemas de computación, con una orientación metódica, ordenada y cuantificable al incremento, ejecución y conservación del software
Objetivos:

#### Diseñar:

Aplicaciones informáticas que se ajusten a las necesidades de las organizaciones.

#### Dirigir: 

Y coordinar el desarrollo de aplicaciones complejas.

#### Intervenir: 

En todas las fases del ciclo de vida de un producto.

#### Estimar: 

Los costes de un proyecto y determinar los tiempos de desarrollo.

#### Hacer:

El seguimiento de costes y plazos.

#### Dirigir: 

Equipos de trabajo de desarrollo software.

#### Organizar:

La realización de pruebas que verifiquen el correcto funcionamiento de los programas y que se ajustan a los requisitos de análisis y diseño.

#### Diseñar, construir y administrar bases de datos.

#### Dirigir:

Y asesorar a los programadores durante el desarrollo de aplicaciones.

#### Introducir:

Procedimientos de calidad en los sistemas, evaluando métricas e indicadores y controlando la calidad del software producido.

#### Organizar

Y supervisar el trabajo de su equipo de los técnicos de mantenimiento y los ingenieros de sistemas y redes.
Cabe destacar como uno de los objetivos de la Titulación todos los aspectos de cooperación social tendentes a la promoción de la cultura, de la paz, la igualdad de derechos con independencia del género, la raza o las particulares condiciones personales o sociales de cualquiera de los miembros de la comunidad universitaria. Desde este punto de vista se hace especial énfasis en la igualdad de oportunidades y no discriminación, favoreciendo de modo muy especial la integración en la comunidad universitaria de personas con necesidades especiales.

### Proceso de ingieneria de Software:

La Ingeniería del Software es una disciplina dentro de la rama informática en constante evolución. En la actualidad la realización de proyectos de software está fuertemente marcada por los procesos involucrados. Dichos procesos identifican el conjunto de tareas y actividades a realizar para la correcta ejecución de un proyecto de software. Consecuencia de ello es la tendencia a la estandarización de dichos procesos por organismos internacionales como marcos de referencia para la realización de proyectos.

En esta asignatura se pretende dotar al alumno del conocimiento de los procesos implicados en la ingeniería del software así como de los principales estándares existentes en el mercado al respecto. Asimismo se abordan las metodologías existentes en relación con dichos procesos.

Antes de matricular la asignatura, verifique los posibles requisitos que pueda tener dentro de su plan. Esta información la encontrará en la pestaña “Plan de estudios” del plan correspondiente.

![_config.yml]({{ site.baseurl }}/images/13.jpg)

### Competencias generales IG:

Conocer los principales procesos implicados en la realización de un proyecto software. Identificar y adoptar los procesos marcados por normas estándares en proyectos software. Adaptar correctamente cuando sea preciso los procesos software a las necesidades de un proyecto. Relacionar distintos procesos identificando la necesidad y el objetivo de cada uno de ellos. Competencias específicas Conocimiento de los procesos en ingeniería del software. Asimilación y capacidad de aplicación de la norma ISO12207. Definición del ciclo de vida aplicable a un proyecto. Asimilación y capacidad de aplicación de CMMI. Conocimiento de las metodologías existentes en ingeniería del software.

### Metodología en la Ingenieria de Software:

Los conocimientos de la asignatura se adquieren a través del estudio razonado de todas las unidades didácticas del manual, así como del material didáctico complementario que se ponga a disposición de los estudiantes en el Aula Virtual.
Además, es preciso que los estudiantes realicen las actividades de evaluación continua y aprendizaje planificadas en la Guía Docente que se encuentra publicada en el Aula Virtual.

Dado el carácter integrador del programa de la asignatura de Procesos en Ingeniería del Software, se recomienda asimilar debidamente todos los conceptos antes de pasar a la siguiente unidad. Esto es así, porque cada nuevo concepto está altamente relacionado con los conceptos vistos en unidades anteriores. Igualmente, la asignatura está muy orientada a la realización de ejercicios prácticos, casos y supuestos, por lo que es muy útil la realización de los ejercicios de autocomprobación de cada unidad.
Dedicación requerida

Se estima que la lectura y comprensión de los contenidos teóricos abarcados en las diversas unidades didácticas ocupará aproximadamente unas 60 horas, mientras la realización de las Actividades de Evaluación Continua (AECs), las Actividades de Aprendizaje y la realización de los Controles, llevará unas 75 horas aproximadamente. También podemos considerar que con el empleo de unas 15 horas por parte del alumno, de cara a preparar el examen final presencial, será suficiente para consolidar los conocimientos y habilidades adquiridas durante el trascurso de la asignatura.

### Tutorías:

La participación en las tutorías, que serán adaptadas en función de las características y necesidades de cada estudiante, también es muy recomendable. Estas sesiones de tutorización se realizarán prioritariamente utilizando los foros virtuales o el teléfono.
A continuación se recogen diferentes recursos de apoyo para la metodología de la asignatura:
Aula Virtual: Por medio del aula el estudiante se puede comunicar a cualquier hora con su profesor y con sus compañeros.
Materiales didácticos
Para el desarrollo del aprendizaje teórico, sobre el que versará el examen final, se proporcionará al estudiante un manual constituido por unidades didácticas, que se corresponden con la descripción de contenidos de la asignatura. Este manual podrá tener diferentes formatos dependiendo de la asignatura.
La bibliografía recomendada y los materiales complementarios asociados al desarrollo de cada asignatura serán facilitados en el Aula Virtual al hilo del desarrollo de las unidades didácticas.

### El Proceso de Software:

Proceso de software La meta de la ingeniería de software es construir productos de software, o mejorar los existentes; en ingeniería de procesos, la meta es desarrollar o mejorar procesos.
Un proceso de desarrollo de software es un conjunto de personas, estructuras de organización, reglas, políticas, actividades y sus procedimientos, componentes de software, metodologías, y herramientas utilizadas o creadas específicamente para definir, desarrollar, ofrecer un servicio, innovar y extender un producto de software.

Un proceso de software efectivo habilita a la organización a incrementar su productividad al desarrollar software:
•	Permite estandarizar esfuerzos, promover reuso, repetición y consistencia entre proyectos.
•	Provee la oportunidad de introducir mejores prácticas de la industria.
•	Permite entender que las herramientas deben ser utilizadas para soportar un proceso.
•	Establece la base para una mayor consistencia y mejoras futuras.
Un proceso de software mejora los esfuerzos de mantenimiento y soporte:
•	Define cómo manejar los cambios y liberaciones a sistemas de software existentes.
•	Define cómo lograr la transición del software a la operación, y cómo ejecutar los esfuerzos de operación y soporte.
•	Necesitamos un proceso de software cuya funcionalidad esté probada en la práctica, y personalizado para que cumpla con nuestras necesidades específicas.

### Ciclo de Vida de un Software:

ESPECIFICACIONES:
Formalizamos los requerimientos; el documento obtenido en la etapa anterior se tomará como punto de partida para esta etapa.

#### ANÁLISIS:
Determinamos los elementos que intervienen en el sistema a desarrollar, su estructura, relaciones, evolución temporal, funcionalidades, tendremos una descripción clara de qué producto vamos a construir, qué funcionalidades aportará y qué comportamiento tendrá.
#### DISEÑO:
Ya sabemos qué hacer, ahora tenemos que determinar cómo debemos hacerlo (¿cómo debe ser construido el sistema en cuestion?; definimos en detalle entidades y relaciones de las bases de datos, seleccionamos el lenguaje que vamos a utilizar, el Sistema Gestor de Bases de Datos, etc.).
#### IMPLEMENTACIÓN:
Empezamos a codificar algoritmos y estructuras de datos, de- finidos en las etapas anteriores, en el correspondiente lenguaje de programación o para un determinado sistema gestor de bases de datos. En muchos proyectos se pasa directamente a esta etapa; son proyectos muy arriesgados que adoptan un modelo de ciclo de vida de code & fix (codificar y corregir) donde se eliminan las etapas de especificaciones, análisis y diseño con la consiguiente pérdida de control sobre la gestión del proyecto.
#### DEBUGGING:
El objetivo de esta etapa es garantizar que nuestro programa no contiene errores de diseño o codificación. En esta etapa no deseamos saber si nuestro programa realiza lo que solicitó el usuario, esa tarea le corresponde a la etapa de implementación. En ésta deseamos encontrar la mayor cantidad de errores. Todas los programas contienen errores: encontrarlos es cuestión de tiempo. Lo ideal es encontrar la mayoría, si no todos, en esta etapa. También se pueden agregar testeos de performance.
#### VALIDACIÓN:
Esta etapa tiene como objetivo la verificación de que el sistema desarrollado cumple con los requerimientos expresados inicialmente por el cliente y que han dado lugar al presente proyecto. En muchos proyectos las etapas de validación y debugging se realizan en paralelo por la estrecha relación que llevan. Sin embargo, tenemos que evitar la confusión: podemos realizarlos en paralelo, pero no como una única etapa.
#### EVOLUCIÓN:
En la mayoría de los proyectos se considera esta etapa como Mantenimiento y evolución, y se le asigna, no sólo el agregado de nuevas funcionalidades (evolución); sino la corrección de errores que surgen (mantenimiento). En la práctica esta denominación no es del todo errónea, ya que es posible que aun luego de una etapa de debugging y validación exhaustiva, se filtren errores.

### El Proceso de desarrollo de Software:

Un proceso de desarrollo de software tiene como propósito la producción eficaz y eficiente de un producto software que reúna los requisitos del cliente. Dicho proceso, en términos globales se muestra en la Figura 2 . Este proceso es intensamente intelectual, afectado por la creatividad y juicio de las personas involucradas. Aunque un proyecto de desarrollo de software es equiparable en muchos aspectos a cualquier otro proyecto de ingeniería, en el desarrollo de software hay una serie de desafíos adicionales, relativos esencialmente a la naturaleza del producto obtenido. A continuación se explican algunas particularidades asociadas al desarrollo de software y que influyen en su proceso de construcción.

Un producto software en sí es complejo, es prácticamente inviable conseguir un 100% de confiabilidad de un programa por pequeño que sea. Existe una inmensa combinación de factores que impiden una verificación exhaustiva de las todas posibles situaciones de ejecución que se puedan presentar (entradas, valores de variables, datos almacenados, software del sistema, otras aplicaciones que intervienen, el hardware sobre el cual se ejecuta, etc.). Un producto software es intangible y por lo general muy abstracto, esto dificulta la definición del producto y sus requisitos, sobre todo cuando no se tiene precedentes en productos software similares. Esto hace que los requisitos sean difíciles de consolidar tempranamente. Así, los cambios en los requisitos son inevitables, no sólo después de entregado en producto sino también durante el proceso de desarrollo.

Además, de las dos anteriores, siempre puede señalarse la inmadurez de la ingeniería del software como disciplina, justificada por su corta vida comparada con otras disciplinas de la ingeniería. Sin embargo, esto no es más que un inútil consuelo.
El proceso de desarrollo de software no es único. No existe un proceso de software universal que sea efectivo para todos los contextos de proyectos de desarrollo. Debido a esta diversidad, es difícil automatizar todo un proceso de desarrollo de software.
A pesar de la variedad de propuestas de proceso de software, existe un conjunto de actividades fundamentales que se encuentran presentes en todos ellos:

•	Especificación de software: Se debe definir la funcionalidad y restricciones operacionales que debe cumplir el software.
•	Diseño e Implementación: Se diseña y construye el software de acuerdo a la especificación.
•	Validación: El software debe validarse, para asegurar que cumpla con lo que quiere el cliente.
•	Evolución: El software debe evolucionar, para adaptarse a las necesidades del cliente.
•	Además de estas actividades fundamentales, Pressman menciona un conjunto de “actividades protectoras”, que se aplican a lo largo de todo el proceso del software. Ellas se señalan a continuación:
•	Seguimiento y control de proyecto de software.
•	Revisiones técnicas formales.
•	Garantía de calidad del software.
•	Gestión de configuración del software.
•	Preparación y producción de documentos.
•	Gestión de reutilización.
•	Mediciones.
•	Gestión de riesgos.
Pressman caracteriza un proceso de desarrollo de software como se muestra en la Figura 3. Los elementos involucrados se describen a continuación:
•	Un marco común del proceso, definiendo un pequeño número de actividades del marco de trabajo que son aplicables a todos los proyectos de software, con independencia del tamaño o complejidad.
•	Un conjunto de tareas, cada uno es una colección de tareas de ingeniería del software, hitos de proyectos, entregas y productos de trabajo del software, y puntos de garantía de calidad, que permiten que las actividades del marco de trabajo se adapten a las características del proyecto de software y los requisitos del equipo del proyecto.
•	Las actividades de protección, tales como garantía de calidad del software, gestión de configuración del software y medición, abarcan el modelo del proceso. Las actividades de protección son independientes de cualquier actividad del marco de trabajo y aparecen durante todo el proceso.

### Metodologías ágiles en el desarrollo de software:

![_config.yml]({{ site.baseurl }}/images/15.jpg)

Históricamente, el desarrollo de software ha sido una tarea tediosa y compleja, donde muchas veces la rentabilidad de la misma estaba muy por debajo de su coste. Eran épocas de desarrollos interminables, de infinidad de líneas de código donde cualquier cambio en el proyecto inicial suponía un auténtico quebradero de cabeza para el desarrollador. La poca (o nula) tolerancia y/o previsión a cambios, los métodos arcaicos de programación, etc. no contribuían a generar un ecosistema adecuado para el correcto desarrollo de software.
Con el paso de los años, fueron surgiendo nuevos lenguajes de programación (en teoría más sencillos…), entornos más amigables, frameworks que facilitaban muchas tareas, conceptos que las empresas dedicadas al desarrollo de software acogieron rápidamente para mejorar la calidad y los plazos de entrega de sus proyectos. Pero, ¿es esto suficiente en la actualidad?
Obviamente, ¡NO!
En un mundo tan cambiante, donde predominan los tiempos y la rentabilidad, muchas veces las empresas olvidan el tercer factor fundamental… la calidad. Pero, ¿es posible meter estas tres variables en la ecuación y obtener un resultado positivo?
Obviamente, ¡SÍ!

### 12 Principios Del Manifiesto Ágil:

1.	Nuestra mayor prioridad es satisfacer al cliente mediante la entrega temprana y continua de software con valor.
2.	Aceptamos que los requisitos cambien, incluso en etapas tardías del desarrollo. Los procesos Ágiles aprovechan el cambio para proporcionar ventaja competitiva al cliente.
3.	Entregamos software funcional frecuentemente, entre dos semanas y dos meses, con preferencia al periodo de tiempo más corto posible.
4.	Los responsables de negocio y los desarrolladores trabajamos juntos de forma cotidiana durante todo el proyecto.
5.	Los proyectos se desarrollan en torno a individuos motivados. Hay que darles el entorno y el apoyo que necesitan, y confiarles la ejecución del trabajo.
6.	El método más eficiente y efectivo de comunicar información al equipo de desarrollo y entre sus miembros es la conversación cara a cara.
7.	El software funcionando es la medida principal de progreso.
8.	Los procesos Ágiles promueven el desarrollo sostenible. Los promotores, desarrolladores y usuarios debemos ser capaces de mantener un ritmo constante de forma indefinida.
9.	La atención continua a la excelencia técnica y al buen diseño mejora la Agilidad.
10.	La simplicidad, o el arte de maximizar la cantidad de trabajo no realizado, es esencial.
11.	Las mejores arquitecturas, requisitos y diseños emergen de equipos auto-organizados.
12.	A intervalos regulares el equipo reflexiona sobre cómo ser más efectivo para a continuación ajustar y perfeccionar su comportamiento en consecuencia.
Por tanto, las tres variables se asocian perfectamente en la ecuación “metodologías ágiles”, lo que significa que una empresa dedicada al desarrollo de software que no opte por una metodología ágil difícilmente podrá sobrevivir al entorno actual pero, sobre todo, a los nuevos tiempos que se avecinan.
Es decir, la duda no debería ser ¿es necesario utilizar una metodología ágil para desarrollar software? La duda, más bien, debería ser ¿qué metodología ágil escojo para desarrollar software?
Algunas de las principales opciones, a día de hoy, son:
1.	Scrum: “Scrum es un marco de trabajo para desarrollar, entregar y mantener productos complejos”.
2.	eXtreme Programming (XP): “Extreme Programming (XP) es un marco de desarrollo de software ágil que tiene como objetivo producir software de mayor calidad y una mejor calidad de vida para el equipo de desarrollo.”
3.	Kanban: “Sistema de información que controla de modo armónico la fabricación de los productos necesarios en la cantidad y tiempo necesarios en cada uno de los procesos.”
4.	Scrumban: metodología que utiliza lo mejor de scrum y de kanban.
5.	Lean: “Originado en el Sistema de Producción de Toyota, este método ofrece todo un marco teórico sólido y basado en la experiencia, para las prácticas ágiles de gestión.”
6.	Feature-Driven Development (FDD): “Feature-Driven Development (FDD) es una metodología ágil basada en la calidad y el monitoreo constante del proyecto.”
7.	Test-Driven Development (TDD): “Test-Driven Development es un proceso de desarrollo de software que se basa en la repetición de un ciclo de desarrollo muy corto: los requisitos se convierten en casos de prueba muy específicos, luego se mejora el software para pasar las nuevas pruebas.”

Un proceso de software ágil debe adaptarse incrementalmente. Para lograr la adaptación incremental, un equipo ágil requiere retroalimentación con el cliente (de modo que sea posible hacer las adaptaciones apropiadas). Un catalizador eficaz para la retroalimentación con el cliente es un prototipo operativo o una porción de un sistema operativo. 
